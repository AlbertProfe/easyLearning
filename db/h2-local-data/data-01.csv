id,version,question,level,solution,hint,explanation,category,framework,language,sub_category,subtopic,topic,answer1,answer2,answer3,answer4,answer5,answer6
1000,1,"What is the purpose of the useState hook in React?","1",1,"Think about managing component state.","The useState hook in React is used to add state to functional components, which were previously stateless. Before hooks, state management was only possible in class components using 'this.state'. With useState, you can declare a state variable and a function to update it, returned as an array. For example, consider a counter component: `const [count, setCount] = useState(0);`. Here, 'count' is the state variable initialized to 0, and 'setCount' is the function to update it. When you call 'setCount(count + 1)', React re-renders the component with the updated 'count' value. This makes useState fundamental for handling dynamic data in React applications.","PROGRAMMING","REACT","JSX","WEB","FUNDAMENTAL_HOOKS","HOOKS","To manage state in functional components","To fetch data from an API","To handle side effects","To memoize values","To create refs","To optimize performance"
1001,1,"How do you initialize a state variable with useState?","1",1,"Look at the syntax of useState.","The useState hook is called with an initial value to set up a state variable in a React functional component. The syntax is `const [state, setState] = useState(initialValue);`. The initial value can be a number, string, object, or any data type. For instance, `const [name, setName] = useState('John');` initializes 'name' to 'John'. When the component first renders, 'name' starts as 'John', and you can update it with 'setName'. This is crucial for setting up the starting point of your component's state, making it reactive to user interactions or other changes.","PROGRAMMING","REACT","JSX","WEB","FUNDAMENTAL_HOOKS","HOOKS","useState(initialValue)","useState(setState)","useState({})","useState([])","useState(null)","useState(undefined)"
1002,1,"What does useState return in React?","1",1,"Consider what you destructure from useState.","The useState hook returns an array with exactly two elements: the current state value and a function to update it. This is typically destructured as `const [value, setValue] = useState(initialValue);`. For example, in `const [age, setAge] = useState(25);`, 'age' is the current state (initially 25), and 'setAge' is the function to change it, like `setAge(26)`. This pair allows you to both access and modify the state, triggering a re-render when updated. Understanding this return value is key to effectively using state in React functional components.","PROGRAMMING","REACT","JSX","WEB","FUNDAMENTAL_HOOKS","HOOKS","An array with state and setter","A single state value","A callback function","An object with state properties","A promise","A boolean"
1003,1,"How do you update state using useState?","1",2,"Focus on the second item returned by useState.","To update state with useState, you use the setter function returned by the hook. For example, if you have `const [count, setCount] = useState(0);`, you update 'count' by calling `setCount(newValue)`. Suppose you want to increment it: you'd write `setCount(count + 1)`. This tells React to re-render the component with the new value. Unlike class components where you merge state with 'setState', useState replaces the state entirely with the new value. This straightforward approach simplifies state updates in functional components.","PROGRAMMING","REACT","JSX","WEB","FUNDAMENTAL_HOOKS","HOOKS","count = count + 1","setCount(count + 1)","useState(count + 1)","updateCount(count + 1)","state.count++","setState({ count: count + 1 })"
1004,1,"What happens when you call the useState setter function?","1",1,"Think about React's rendering process.","When you call the setter function from useState, like `setCount(count + 1)`, React schedules a re-render of the component with the new state value. For example, in `const [count, setCount] = useState(0);`, calling `setCount(5)` updates 'count' to 5 on the next render. This doesn't happen instantlyâ€”it's asynchronous. React batches state updates for performance, then re-renders the component, reflecting the new state in the UI. This mechanism ensures your component stays in sync with its state, making it reactive to changes like user inputs or events.","PROGRAMMING","REACT","JSX","WEB","FUNDAMENTAL_HOOKS","HOOKS","The component re-renders","The state resets to initial value","The component unmounts","The setter throws an error","The state updates synchronously","Nothing happens"
1005,1,"Can useState hold complex data like objects?","1",1,"Consider the flexibility of state in React.","Yes, useState can manage complex data types like objects or arrays. You pass the initial object to useState, such as `const [user, setUser] = useState({ name: 'Alice', age: 30 });`. To update it, you call the setter with a new object, often using the spread operator to preserve other properties: `setUser({ ...user, age: 31 });`. This replaces the old state with the new object. For example, a form component might use this to track multiple input fields, making useState versatile for handling structured data in React applications.","PROGRAMMING","REACT","JSX","WEB","FUNDAMENTAL_HOOKS","HOOKS","Yes, it can hold objects","No, only primitive types","Only strings","Only numbers","Only booleans","Only arrays"
1006,1,"Why might you use multiple useState calls in one component?","1",1,"Think about organizing different pieces of state.","Using multiple useState calls allows you to manage independent pieces of state separately, improving clarity and control. For instance, in a form, you might have `const [name, setName] = useState('');` and `const [email, setEmail] = useState('');`. Each has its own setter, like `setName('Bob')`, without affecting 'email'. This avoids lumping everything into one object (e.g., `setForm({ ...form, name: 'Bob' })`), which can get messy with many fields. Multiple useState calls make updates straightforward and keep your code modular.","PROGRAMMING","REACT","JSX","WEB","FUNDAMENTAL_HOOKS","HOOKS","To manage separate state variables","To optimize performance","To fetch multiple APIs","To handle side effects","To memoize values","To create refs"
1007,1,"What is a common use case for useState in React?","1",1,"Think about interactive UI elements.","A common use case for useState is handling user input, like in a form or a counter. For example, in a counter component, you'd use `const [count, setCount] = useState(0);` and a button with `onClick={() => setCount(count + 1)}`. Each click updates 'count', and React re-renders the UI to show the new value. This makes useState perfect for dynamic, interactive elements where the UI needs to reflect state changes, such as toggling visibility, storing input data, or tracking clicks, keeping the component responsive.","PROGRAMMING","REACT","JSX","WEB","FUNDAMENTAL_HOOKS","HOOKS","Handling user input","Fetching data","Routing navigation","Styling components","Creating refs","Optimizing renders"
1008,1,"Can you call useState conditionally in a component?","1",2,"Consider React's rules for hooks.","No, you cannot call useState conditionally because React relies on a consistent order of hook calls to track state correctly. For example, putting `if (condition) { const [count, setCount] = useState(0); }` inside a condition breaks this order across renders, confusing React. Instead, call useState at the top level, like `const [count, setCount] = useState(condition ? 0 : 10);`. This rule ensures React can match state to the right hook call, maintaining predictable behavior in your component.","PROGRAMMING","REACT","JSX","WEB","FUNDAMENTAL_HOOKS","HOOKS","Yes, inside if statements","No, only at the top level","Yes, inside loops","Yes, inside nested functions","No, only in class components","Yes, anywhere in the component"
1009,1,"How do you reset state to its initial value with useState?","1",1,"Think about how the setter works.","To reset state to its initial value with useState, you call the setter function with the original value passed to useState. For example, with `const [count, setCount] = useState(0);`, you reset it by calling `setCount(0)`. This sets 'count' back to 0, triggering a re-render. In a component, you might tie this to a 'Reset' button: `<button onClick={() => setCount(0)}>Reset</button>`. This simple approach leverages the setter's ability to overwrite the current state, making it easy to revert to the starting point.","PROGRAMMING","REACT","JSX","WEB","FUNDAMENTAL_HOOKS","HOOKS","Call setCount(0)","Call useState(0) again","Set count = 0 directly","Use resetState(0)","Refresh the component","Use a ref instead"
